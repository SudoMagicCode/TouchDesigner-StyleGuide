"use strict";(self.webpackChunktdStyleGuide=self.webpackChunktdStyleGuide||[]).push([[3810],{8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var i=n(6540);const o={},s=i.createContext(o);function r(e){const t=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:t},e.children)}},9552:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"SM-guide/nodes/debugging","title":"Visual Debugging","description":"Testing how things work","source":"@site/docs/SM-guide/nodes/004-debugging.md","sourceDirName":"SM-guide/nodes","slug":"/SM-guide/nodes/debugging","permalink":"/docs/SM-guide/nodes/debugging","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Visual Debugging","description":"Testing how things work"},"sidebar":"tutorialSidebar","previous":{"title":"Wires","permalink":"/docs/SM-guide/nodes/wires"},"next":{"title":"Python in TD","permalink":"/docs/SM-guide/python-in-td"}}');var o=n(4848),s=n(8453);const r={title:"Visual Debugging",description:"Testing how things work"},a=void 0,d={},l=[{value:"Animation",id:"animation",level:3},{value:"Links",id:"links",level:3},{value:"Docked",id:"docked",level:3}];function c(e){const t={h3:"h3",p:"p",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h3,{id:"animation",children:"Animation"}),"\n",(0,o.jsx)(t.p,{children:"Animated wires help you see, at a glance, that something is cooking. This is a visual reminder that a portion of your network is being processed right before your very eyes. This is often helpful in understanding how to debug a portion of your network as it allows you to find unnecessary cycles visually rather than with print statements."}),"\n",(0,o.jsx)(t.h3,{id:"links",children:"Links"}),"\n",(0,o.jsx)(t.p,{children:"The dotted lines that connect ops are refereed to as links, not wires. Wires are inter-operator connections between data types (families), links, on the other hand, bridge between operator types and between data types. These are often used to drive parameters, or animate some portion of the network. Just like with wires, animated links are an indicator that a process is cooking. This is another important visual debugging mechanism when working on a project."}),"\n",(0,o.jsx)(t.h3,{id:"docked",children:"Docked"}),"\n",(0,o.jsx)(t.p,{children:"Docked ops have a straight line, similar to a link in color, that connects an operator to another. Docking an operator keeps it at an established x and y offset from its partner."}),"\n",(0,o.jsx)(t.p,{children:"While there isn\u2019t a defined flow, there is an implied western bias in a left to right flow in networks. While you certainly can organize your networks right to left, it will make for some backwards flipping lines. Similarly, organizing top to bottom will creating hard snaking S curves in your networks. While none of these things are inherently bad, they can make it difficult for another programmer to interpret your intentions. Top to bottom or bottom to top is perhaps the most dangerous. This particular arrangement makes it difficult to see, at a glance, the intended flow of operations."})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}}}]);