{"searchDocs":[{"title":"Placeholder","type":0,"sectionRef":"#","url":"/docs/HQ-guide/new-page","content":"Placeholder","keywords":"","version":"Next"},{"title":"A Simple Disclaimer","type":0,"sectionRef":"#","url":"/docs/intro","content":"A Simple Disclaimer A style guide is opinionated, on purpose. While many people perceive the act of writing code as logical and un-biased, any developer who has seen their share of spaghetti understands first hand that code is mostly (for now at least1) written by humans - and humans are deeply opinionated. For those coming to TouchDesigner from other text based languages, you're probably familiar the idea of a Style Guide. In other languages these often provide anchoring ideas about the best practice for a particular project or how an organization writes its code. Many are familiar with conventions found in the Google Style Guides or in PEP 8 - this resource makes no assumptions of importance, but does recognize the value of strong anchors for developers when they're writing code or connecting nodes. Style guides are just that, guides. The suggestions outlined here aren‚Äôt hard and fast rules, but form and style conventions from people who have tried lots of different approaches, and made plenty of mistakes of their own. For any standard there are likely to be exceptions, challenges, and issues. Code the way you want to code, but also remember that you‚Äôre making something that other programmers (your future self included2) are going to return to, pull apart, question, interrogate, curse, praise, and judge. Your act of fixing an idea in an operational structure is both a creative act, as well as a measured and considered one. TouchDesigner networks are challenging to share and collaborate in ‚Äì they are sprawling, nested, multi-layered collections of signal flows. That is to say that they are already challenging to decode ‚Äì you don‚Äôt have to use this standard, but cultivate and implement one for your own sake, and for the sake of your collaborators. Footnotes‚Äã It's currently 2023, and TikTok cannot stop talking about how chatGPT will write all code in the near future... maybe even travel back from the future and write all the code in a LLM DeLorean. ‚Ü© There's an xkcd for everything ‚Ü©","keywords":"","version":"Next"},{"title":"The Interactive & Immersive HQ Style Guide","type":0,"sectionRef":"#","url":"/docs/HQ-guide","content":"The Interactive &amp; Immersive HQ Style Guide Whatever preamble you'd like to add here üìÑÔ∏è Placeholder Placeholder","keywords":"","version":"Next"},{"title":"GLSL in TouchDesigner","type":0,"sectionRef":"#","url":"/docs/SM-guide/glsl-in-td/glsl-comments","content":"","keywords":"","version":"Next"},{"title":"Links to Derivative's official docs‚Äã","type":1,"pageTitle":"GLSL in TouchDesigner","url":"/docs/SM-guide/glsl-in-td/glsl-comments#links-to-derivatives-official-docs","content":"","version":"Next","tagName":"h2"},{"title":"SudoMagic Style Guide","type":0,"sectionRef":"#","url":"/docs/SM-guide","content":"SudoMagic Style Guide Style and voice are different. Style is standard conventions of writing. Voice is the distinct way an individual puts words together. All good writers have a near-uniform understanding of style but a voice all their own. ‚Äï Naveed Saleh, The Complete Guide to Article Writing: How to Write Successful Articles for Online and Print Markets There are as many ways to use TouchDesigner as there are developers and artists that use TouchDesigner. To that end, the aim of a style guide is to provide standards and conventions that we agree upon as a working schema. This has a number of benefits: it ensures networks follow patterns that are easier for developers to quickly navigate and readit reduces the cognitive energy required for moving between projects (shared project architectures create reliability and consistency)it allows for easier code review and discussion between developersit allows us to work with other developers and artists by using an established and reliable structure This style guide aims to capture our working standards at SudoMagic, both for network set-up, project structure, and for the use of Python and GLSL in the context of TouchDesigner. üìÑÔ∏è Preferences An overview of TouchDesigner preferences üìÑÔ∏è Network Organization Organizing your thoughts and your noodles üóÉÔ∏è Nodes 4 items üóÉÔ∏è Python in TD 5 items üóÉÔ∏è GLSL 3 items üìÑÔ∏è Project Organization Setting up your project üìÑÔ∏è Externalizing TOX Files An examination of the use of TOX files when building your project üìÑÔ∏è Comments In network documentation üìÑÔ∏è Logging Keeping track of what went right and wrong üìÑÔ∏è System Configuration Configuring your project from file","keywords":"","version":"Next"},{"title":"GLSL in TouchDesigner","type":0,"sectionRef":"#","url":"/docs/SM-guide/glsl-in-td/glsl-includes","content":"","keywords":"","version":"Next"},{"title":"Links to Derivative's official docs‚Äã","type":1,"pageTitle":"GLSL in TouchDesigner","url":"/docs/SM-guide/glsl-in-td/glsl-includes#links-to-derivatives-official-docs","content":"","version":"Next","tagName":"h2"},{"title":"Externalizing TOX Files","type":0,"sectionRef":"#","url":"/docs/SM-guide/external-tox-files","content":"","keywords":"","version":"Next"},{"title":"Directories and Saving‚Äã","type":1,"pageTitle":"Externalizing TOX Files","url":"/docs/SM-guide/external-tox-files#directories-and-saving","content":" Structurally, we build our repo directories to match our toe file directories. If a given base is located in /software_project_name/base_communication, then it‚Äôs tox file should be saved at a repo location that matches. The thinking here is to build parallel structures between networks and directories. Why? You might ask. Mirroring directory structures can help other programmers locate your work. This conventionalized method of locating files, means that if you know where a given module lives in a network, you should also be able to locate that file in the reop. For any frustration this may cause during building, it solves an innumerable number of problems during debugging and code exchange.  ","version":"Next","tagName":"h2"},{"title":"Node Naming Conventions‚Äã","type":1,"pageTitle":"Externalizing TOX Files","url":"/docs/SM-guide/external-tox-files#node-naming-conventions","content":" Clear namespace use is essential to any project. If you‚Äôre familiar with the Zen of Python, you might remember two essential ideas:  Explicit is better than implicitNamespaces are one honking great idea ‚Äî let‚Äôs do more of those!  What does this have to do with naming contentions? It‚Äôs easy to find yourself navigating another programmers network trying to discern what they were attempting to do ‚Äì even trying on how they might have been thinking about a given project or idea. For this very reason we‚Äôve landed on the explicit prefixing of unique node names in a TouchDesigner network with the operators‚Äô type. For example, a null TOP used as a background element might have the name ‚Äúnull_bg‚Äù. While this makes for longer operator names, it also allows other programmers the opportunity to see, at a glance, what operators are in a given network or process. While this may initially feel cumbersome, this convention is ultimately about making your code as parse-able and readable for another programmer as possible. This is also about creating code for your future self - coming back to a project in 2, 5, or 10 months means you‚Äôll likely want as many breadcrumbs as possible in order to understand what your past self was trying to do.  ","version":"Next","tagName":"h2"},{"title":"Notable Exceptions to this Rule‚Äã","type":1,"pageTitle":"Externalizing TOX Files","url":"/docs/SM-guide/external-tox-files#notable-exceptions-to-this-rule","content":" The most apparent exceptions to this rule are found in local/modules. Mods have the benefit of being accessible with the short hand:  mod.textDATname.functionName  This excellent feature can be ham-stringed by long text DAT names. As an example, we might imagine that we have a module we‚Äôd like to use with the mod. shorthand. THat module‚Äôs name might easily be something like ‚Äútext_system_configuration‚Äù when using our standard naming convention, inside of this module we might want to use a function called ‚Äústart_up‚Äù. This would mean that we‚Äôd need to write something akin to:  mod.text_system_configuration.start_up()  in order to call this function. The shortening of this by the prefix text_ may not be a huge number of characters, but it helps provide a little bit of clarity in the reading a of the expression:  mod.system_configuration.start_up()  This also helps distinguish our module - which is essentially being accessed as a library - and a regular text DAT. ","version":"Next","tagName":"h3"},{"title":"GLSL in TouchDesigner","type":0,"sectionRef":"#","url":"/docs/SM-guide/glsl-in-td/glsl-in-td-overview","content":"","keywords":"","version":"Next"},{"title":"Links to Derivative's official docs‚Äã","type":1,"pageTitle":"GLSL in TouchDesigner","url":"/docs/SM-guide/glsl-in-td/glsl-in-td-overview#links-to-derivatives-official-docs","content":"","version":"Next","tagName":"h2"},{"title":"Logging","type":0,"sectionRef":"#","url":"/docs/SM-guide/logging","content":"","keywords":"","version":"Next"},{"title":"Events and Debugging‚Äã","type":1,"pageTitle":"Logging","url":"/docs/SM-guide/logging#events-and-debugging","content":" New log files should be generated for each day - ensuring that no single log file is an unreasonable length to parse. The SudoMagic logging module is configured to output log files to _public/logs. The _public folder location is partially derived for the TD project file. This means that it may or may not exist alongside the .toe file.  - Print only during development While the print() command is often helpful and quick to use during development, it can produce cluttered messages that are difficult to parse in the text port when possible, remove or comment out print statements that have been used during development and use the logging module for any messages that will produce useful messages in the final project.  Logging requires that you import the logging module into any extension or script that requires logging:  import logging   Ideally, log messages should be traceable to sensible sources. For example class singletons should identify if a log message belongs to them - i.e.  logging.info(&quot;PROJECT | System settings loded sucessfully&quot;)   ","version":"Next","tagName":"h2"},{"title":"Links to Derivative's official docs‚Äã","type":1,"pageTitle":"Logging","url":"/docs/SM-guide/logging#links-to-derivatives-official-docs","content":" ","version":"Next","tagName":"h2"},{"title":"Additional Support docs‚Äã","type":1,"pageTitle":"Logging","url":"/docs/SM-guide/logging#additional-support-docs","content":" Python Logging Module ","version":"Next","tagName":"h2"},{"title":"Comments","type":0,"sectionRef":"#","url":"/docs/SM-guide/network-comments","content":"","keywords":"","version":"Next"},{"title":"Links to Derivative's official docs‚Äã","type":1,"pageTitle":"Comments","url":"/docs/SM-guide/network-comments#links-to-derivatives-official-docs","content":"","version":"Next","tagName":"h2"},{"title":"Naming Patterns","type":0,"sectionRef":"#","url":"/docs/SM-guide/nodes/naming","content":"","keywords":"","version":"Next"},{"title":"Notable Exceptions‚Äã","type":1,"pageTitle":"Naming Patterns","url":"/docs/SM-guide/nodes/naming#notable-exceptions","content":" The most apparent exceptions to this rule are found in local/modules. Mods have the benefit of being accessible with the short hand:  mod.textDATname.functionName  This excellent feature can be ham-stringed by long text DAT names. As an example, we might imagine that we have a module we‚Äôd like to use with the mod. shorthand. That module‚Äôs name might easily be something like ‚Äútext_system_configuration‚Äù when using our standard naming convention, inside of this module we might want to use a function called ‚Äústart_up‚Äù. This would mean that we‚Äôd need to write something akin to:  mod.text_system_configuration.start_up()  in order to call this function. The shortening of this by the prefix ‚Äútext_‚Äù may not be a huge number of characters, but it helps provide a little bit of clarity in the reading a of the expression:  mod.system_configuration.start_up()  This also helps distinguish our module ‚Äì which is essentially being accessed as a library ‚Äì and a regular text DAT. ","version":"Next","tagName":"h3"},{"title":"Nodes","type":0,"sectionRef":"#","url":"/docs/SM-guide/nodes","content":"Nodes Nodes are the core of the TouchDesigner networking experience. Not only are nodes at the center of the TouchDesigner development experience, their structure and layout communicate important information to both the creator and project collaborators. While there is a thriving community of TouchDesigner artists who focus on conceptualizing their network as a part of their artwork, the projects at SudoMagic are (generally) focused on function over form when it comes to network organization. For that reason we consider the following when building networks. üìÑÔ∏è Naming Patterns Nodes, names, and their predictable patterns üìÑÔ∏è Size Size as a means of communicating with other developers üìÑÔ∏è Wires Connections between Nodes üìÑÔ∏è Visual Debugging Testing how things work","keywords":"","version":"Next"},{"title":"Network Organization","type":0,"sectionRef":"#","url":"/docs/SM-guide/network-organization","content":"","keywords":"","version":"Next"},{"title":"Links to Derivative's official docs‚Äã","type":1,"pageTitle":"Network Organization","url":"/docs/SM-guide/network-organization#links-to-derivatives-official-docs","content":"","version":"Next","tagName":"h2"},{"title":"Visual Debugging","type":0,"sectionRef":"#","url":"/docs/SM-guide/nodes/debugging","content":"","keywords":"","version":"Next"},{"title":"Animation‚Äã","type":1,"pageTitle":"Visual Debugging","url":"/docs/SM-guide/nodes/debugging#animation","content":" Animated wires help you see, at a glance, that something is cooking. This is a visual reminder that a portion of your network is being processed right before your very eyes. This is often helpful in understanding how to debug a portion of your network as it allows you to find unnecessary cycles visually rather than with print statements.  ","version":"Next","tagName":"h3"},{"title":"Links‚Äã","type":1,"pageTitle":"Visual Debugging","url":"/docs/SM-guide/nodes/debugging#links","content":" The dotted lines that connect ops are refereed to as links, not wires. Wires are inter-operator connections between data types (families), links, on the other hand, bridge between operator types and between data types. These are often used to drive parameters, or animate some portion of the network. Just like with wires, animated links are an indicator that a process is cooking. This is another important visual debugging mechanism when working on a project.  ","version":"Next","tagName":"h3"},{"title":"Docked‚Äã","type":1,"pageTitle":"Visual Debugging","url":"/docs/SM-guide/nodes/debugging#docked","content":" Docked ops have a straight line, similar to a link in color, that connects an operator to another. Docking an operator keeps it at an established x and y offset from its partner.  While there isn‚Äôt a defined flow, there is an implied western bias in a left to right flow in networks. While you certainly can organize your networks right to left, it will make for some backwards flipping lines. Similarly, organizing top to bottom will creating hard snaking S curves in your networks. While none of these things are inherently bad, they can make it difficult for another programmer to interpret your intentions. Top to bottom or bottom to top is perhaps the most dangerous. This particular arrangement makes it difficult to see, at a glance, the intended flow of operations. ","version":"Next","tagName":"h3"},{"title":"Wires","type":0,"sectionRef":"#","url":"/docs/SM-guide/nodes/wires","content":"Wires Curved, straight, dotted, moving, static ‚Äì the wires in TouchDesigner are a delight, some kind of series of mad scientists spaghetti code it‚Äôs easy to fall in love with them, and easier still to make a mess of them. There are a few important features of wires to keep in mind when working. Do Think carefully about your node arrangement and how this will affect your wires ‚Äì what will you cross, obscure, or hide?Leave room for clear paths and flows in your network. A little more empty spaces is generally better than too little.Think about the proximity of export nodes to their targets ‚Äì are you creating long or confusing export paths that will be difficult to understand visually? Don‚Äôt Reverse order in node connectionsVertically stack operators and connect them with S-curves.Dock and hide important nodes ‚Äì scripts, notes, shaders, are all examples of acceptable items. NEVER dock and hide essential network elements. By hiding an essential part of your network, you make it exponentially more difficult for another programmer to debug your network, or understand your process.Arrange your nodes haphazardly","keywords":"","version":"Next"},{"title":"Size","type":0,"sectionRef":"#","url":"/docs/SM-guide/nodes/size","content":"Size Like in any paradigm, programmers have strong feelings about the best way to format their programming space. With something like TouchDesigner, the spatialized element of this development platform creates another layer of potential meaning making and organizational space. This also creates opportunities for messy and disorganized habits to crop up. Touch makes it easier to quickly change the size of node to better see it ‚Äì you might find yourself doing this for comments, rendering elements, control panels, chop channels, geometry ‚Äì just about anything in fact. While there is some great utility in this, and you may find that you‚Äôre able to create abstract art pieces with your network, if possible you should avoid unnecessary resizing. Why?! Perhaps the most important consideration is how multiple sizes change the legibility of your network. While it‚Äôs not uncommon that you may find yourself enlarging elements in your network to better see them, it changes your ability to see the network from at a glance ‚Äì to read the flow of the network without unhindered by an imposed frame of importance. Your decision to enlarge a particular TOP or DAT may have been in response to a pragmatic need ‚Äì to an outsider, however, this choice reads ‚Äì visually ‚Äì as an indicator of significance. This injection of priority can undermine your fellow programmers ability to unbiasedly read the flow of information in your network ‚Äì because they‚Äôre trying to decode the implied meaning what may well be perceived as a indication of significance. Sometimes, however, you may find that you want to change the size of an operator for that very reason. What then are you to do? Consider using a command to set the size of your node ‚Äì this can ensure consistent sizes that can be standardized across your networks. This is accessible from the op class: op( 'opName' ).nodeHeight = int op( 'opName' ).nodeWidth = int Height and width are expressed as network editor units. One square on the network is equal to 100 network editor units. Do Use consistent spacing, sizing, and clear organizational flows.Rely on the default sizes of nodes as a starting pointConsider turning off the adaptive sizing for nodes in the options dialogue boxGroup operations together and consider when you might create modules for a * particular process in your network Don‚Äôt Resize your nodes willy nillyUse multiple sizes in your organization structure without providing a key to your viewer or fellow programmersUse extremely large sized nodes. If another programmer resets your node sizes to better read your network, they‚Äôll be placed at great network distances from one another, making the first step in debugging your code an act of organizationForget that your network is something someone else will invariably see, interact with, and need to understand ‚Äì be nice to your future self, or to those that will come after you.","keywords":"","version":"Next"},{"title":"Project Organization","type":0,"sectionRef":"#","url":"/docs/SM-guide/organization","content":"","keywords":"","version":"Next"},{"title":"/base_scaffold‚Äã","type":1,"pageTitle":"Project Organization","url":"/docs/SM-guide/organization#base_scaffold","content":"   SudoMagic's standard project structure is built on top of a paradigm that has two layers of consistent components. SudoMagic's project beings with a base COMP called base_scaffold that acts as the root of any of our projects. This layer of the project contains a the following components:  ","version":"Next","tagName":"h2"},{"title":"base_shaderlib‚Äã","type":1,"pageTitle":"Project Organization","url":"/docs/SM-guide/organization#base_shaderlib","content":" Shader Lib acts as a reusable shader library that should be accessible across all SudoMagic projects. Any given project might have variable elements, but the shader library should be accessible regardless, and with a shortest possible import path as possible. This allows for concise import statements that might be used in any shaders in the project. A universal shader library that's housed in the root of all projects also means that components developed in other environments can be easily ported to other SudoMagic projects.  ","version":"Next","tagName":"h3"},{"title":"local‚Äã","type":1,"pageTitle":"Project Organization","url":"/docs/SM-guide/organization#local","content":" Local's primary purpose in this layer of the project is to house modules on demand for TouchDesigner. local/modules houses our reusable SudoMagic Python libraries. The contents of local/modules is intended to be abstractly reusable across all projects.  ","version":"Next","tagName":"h3"},{"title":"base_project‚Äã","type":1,"pageTitle":"Project Organization","url":"/docs/SM-guide/organization#base_project","content":" Project holds all of the elements that make up a given project. This is the portion of a project that is described by consistent formula of base components, but is also expected to different from project to project.  ","version":"Next","tagName":"h3"},{"title":"cloudPalette‚Äã","type":1,"pageTitle":"Project Organization","url":"/docs/SM-guide/organization#cloudpalette","content":" cloudPalette holds a component use intention is to create fast access to martials from the web. Your cloud palette is the DropBox of TouchDesigner components and snippets. These elements are not natively housed by the TouchDesigner network, but are instead loaded on demand from the cloud.  ","version":"Next","tagName":"h3"},{"title":"base_dev_tools‚Äã","type":1,"pageTitle":"Project Organization","url":"/docs/SM-guide/organization#base_dev_tools","content":" Dev Tools houses the mission critical development components used across all SudoMagic projects. This includes tools like our TOX saving component, logging, performance profiling, and the like.  ","version":"Next","tagName":"h3"},{"title":"/base_scaffold/base_project‚Äã","type":1,"pageTitle":"Project Organization","url":"/docs/SM-guide/organization#base_scaffoldbase_project","content":"   A typical SudoMagic project contains the following persistent elements:  Component\tDescriptionbase_startup\tThis component holds all of the start-up scripting and behavior for the project. Inside of this component you'll find few actual operators, and the addition of a base COMP acts primarily as a clean organization mechanic. iparSettings\tWe use internal parameters as our primary mechanic for collecting all fo the controls for a given project. This component acts as a single source of truth for all project settings. This creates a single operator that holds all parameters - making it easy to both save all settings to file, and load all settings from file quickly and centrally. base_com\tCOM, short for Communication, is the anchor for all network and communication traffic for a given project. This hub for communication acts as our anchor of all IO - making it simple to both make and receive calls. This also acts as the hub for where information is streamed from, or to for multi-machine projects. container_output\tOutput is the only Container component in the network - this component is linked to the standard Window COMP in the root of the TouchDesigner network, and contains any elements that will be rendered or displayed for the project. base_icon\tThis has no functional impact on the project, but houses the icon that's used for the project. local\tLike local in /base_scaffold this holds any pure Python libraries that might be used for this specific project. Additionally, this component holds all of the extension code that will be used for extensions in the project. Extensions are centralized in part to allow for code completion across modules base_process\tProcess servers as a component to house any data processing specific to the project that needs to be accessible across components. base_data\tData acts as a component to house all data for the project. This central point of access holds pieces like models, configuration schemas, and the like.  Class Diagram  Below is a diagram representation of the primitives that make up base class elements that can be extended and modified in each project.    Summary of Network Topology  Scaffold Structure base_scaffold ‚îú‚îÄ‚îÄ base_icon_ui ‚îú‚îÄ‚îÄ local ‚îÇ ‚îî‚îÄ‚îÄ modules ‚îÇ ‚îî‚îÄ‚îÄ SudoMagic ‚îÇ ‚îú‚îÄ‚îÄ base_prod_tools ‚îú‚îÄ‚îÄ base_dev_tools ‚îú‚îÄ‚îÄ base_shader_lib ‚îÇ ‚îî‚îÄ‚îÄ base_project ‚îú‚îÄ‚îÄ base_icon ‚îú‚îÄ‚îÄ base_startup ‚îú‚îÄ‚îÄ iparSettings ‚îú‚îÄ‚îÄ base_com ‚îú‚îÄ‚îÄ container_output ‚îú‚îÄ‚îÄ base_process ‚îú‚îÄ‚îÄ base_data ‚îî‚îÄ‚îÄ local ‚îî‚îÄ‚îÄ modules ‚îú‚îÄ‚îÄ lookup ‚îú‚îÄ‚îÄ project ‚îú‚îÄ‚îÄ com ‚îú‚îÄ‚îÄ process ‚îú‚îÄ‚îÄ output ‚îî‚îÄ‚îÄ data   ","version":"Next","tagName":"h2"},{"title":"Links to Derivative's official docs‚Äã","type":1,"pageTitle":"Project Organization","url":"/docs/SM-guide/organization#links-to-derivatives-official-docs","content":" Base COMP Container COMP ","version":"Next","tagName":"h2"},{"title":"Python in TD","type":0,"sectionRef":"#","url":"/docs/SM-guide/python-in-td","content":"Python in TD Python in TouchDesigner certainly has it's own set of quirks - some of these behaviors stem from the Python, others from TouchDesigner, and finally from the integration between the two. Python's use in TouchDesigner is one of the most powerful ways to both customize TouchDesigner and build complex stand alone systems. Having a nuanced understanding of how to best leverage Python in TouchDesigner unlocks a nearly limitless set of possibilities. This section is devoted to how SudoMagic has standardized it's Python practice for work with TouchDesigner. üìÑÔ∏è Modules Python modules in TouchDesigner üìÑÔ∏è Extensions Python extensions in TouchDesigner üìÑÔ∏è Local Modules A special case for Python modules in TouchDesigner üìÑÔ∏è Auto-Complete An overview of Python autocomplete in VS Code üìÑÔ∏è Python Doc Strings An overview of Python autocomplete in VS Code","keywords":"","version":"Next"},{"title":"Local Modules","type":0,"sectionRef":"#","url":"/docs/SM-guide/python-in-td/local-modules","content":"","keywords":"","version":"Next"},{"title":"The Magical Local/Modules‚Äã","type":1,"pageTitle":"Local Modules","url":"/docs/SM-guide/python-in-td/local-modules#the-magical-localmodules","content":" At SudoMagic we take advantage of this feature in two locations in a typical project. At the root of a project the SudoMagic library is located in base_scaffold/local/modules/SudoMagic. This ensures that our library of reusable functions is available throughout the entire project.  base_scaffold ‚îî‚îÄ‚îÄ local ‚îî‚îÄ‚îÄ modules ‚îî‚îÄ‚îÄ SudoMagic   ","version":"Next","tagName":"h2"},{"title":"Project Specific‚Äã","type":1,"pageTitle":"Local Modules","url":"/docs/SM-guide/python-in-td/local-modules#project-specific","content":" base_scaffold ‚îú‚îÄ‚îÄ base_icon_ui ‚îú‚îÄ‚îÄ local ‚îÇ ‚îî‚îÄ‚îÄ modules ‚îÇ ‚îî‚îÄ‚îÄSudoMagic ‚îÇ ‚îî‚îÄ‚îÄ base_project ‚îî‚îÄ‚îÄ local ‚îî‚îÄ‚îÄ modules ‚îî‚îÄ‚îÄ projectSpecificModules   ","version":"Next","tagName":"h3"},{"title":"Links to Derivative's official docs‚Äã","type":1,"pageTitle":"Local Modules","url":"/docs/SM-guide/python-in-td/local-modules#links-to-derivatives-official-docs","content":"","version":"Next","tagName":"h2"},{"title":"Preferences","type":0,"sectionRef":"#","url":"/docs/SM-guide/preferences","content":"","keywords":"","version":"Next"},{"title":"Recommended Preference Settings‚Äã","type":1,"pageTitle":"Preferences","url":"/docs/SM-guide/preferences#recommended-preference-settings","content":" Preferences is a dialog for setting personal default settings for various TouchDesigner options. These preferences are found in the Edit menu under Preferences.... These options are saved so they apply to your next TouchDesigner session.  From the Edit menu select the Preferences dialog box. Alternatively, you could use the keyboard short-cut Alt + p  Here you‚Äôll find a number of preferences for setting up your TouchDesigner environment. While many of these are the purview of the individual programmer there are some important recommendations worth considering when spending a significant amount of time developing in Touch. You may well find that you have a very specific set of preferences in your work, and that‚Äôs great. But, before you get there here are a few good places to start.  Alternatively, you can find the preference file located here:  Platform\tPathWindows\tC:/Users/{username}/AppData/Local/Derivative/TouchDesigner/pref.txt macOS\t~Library/Application Support/Derivative/TouchDesigner&lt;/pref.txtcode&gt;  ","version":"Next","tagName":"h2"},{"title":"Grid Snap‚Äã","type":1,"pageTitle":"Preferences","url":"/docs/SM-guide/preferences#grid-snap","content":" By default the grid snap setting in TouchDesigner is set to course. Most of the networks you‚Äôll find in our repos have been set with a fine network grid, which means if you re-arrange an operator, it will be difficult to find your way back into alignment with the project. For this reason, it‚Äôs worth changing your Snap to Grid to be fine.  ","version":"Next","tagName":"h2"},{"title":"Resize‚Äã","type":1,"pageTitle":"Preferences","url":"/docs/SM-guide/preferences#resize","content":" For the sanity of other programmers, it‚Äôs well worth turning off the resize TOP and COMP checkboxes in your Network preferences tab. This keeps a uniform look to all TOPs and COMPs unless you choose to specifically deviate from the normal size.  This is often an area of spirited discussion, and programmers often have very specific opinions about the right approach for sizing and network organization. That being said, it‚Äôs worth remembering that a formal structure to the choices made in sizing and placement help make a TouchDesigner network more readable and navigable. First starting with normed sizes allows the programmer to make specific choices, rather than arbitrary ones ‚Äì a common byproduct of the use of auto resizing. for both TOPs and COMPs.  Said another way, if the size and placement of your operators communicates meaning in your networks - then it's in your best intrest to make those decisiosn conscisouly.  ","version":"Next","tagName":"h2"},{"title":"External Editors‚Äã","type":1,"pageTitle":"Preferences","url":"/docs/SM-guide/preferences#external-editors","content":" It‚Äôs often desirable to have an external editor for text and table elements in touch. Many of us use Sublime Text thought there are a wide variety of text editors that you might choose. External editors allow for syntax highlighting, and a variety of advanced features for speeding up the process of writing code. To set an external editor you need to use the DATs tab of the preferences window. Here you‚Äôll find two fields where you can enter the paths to the executables for the applications you‚Äôd like to use.  An example preference file:  dats.texteditor C:/Users/ragan/AppData/Local/Programs/Microsoft VS Code/Code.exe obj.adaptivehomedefault 0 chops.graphdisplay2 6 network.fitpaneltotile 0 general.inc 0 network.zoomdelay 0.19999999 network.gridsnapdiv 2 network.fittoptotile 0 network.zoomboost 1.0000002   ","version":"Next","tagName":"h2"},{"title":"Links to Derivative's official docs‚Äã","type":1,"pageTitle":"Preferences","url":"/docs/SM-guide/preferences#links-to-derivatives-official-docs","content":" Preference DialogPreference Class ","version":"Next","tagName":"h2"},{"title":"Extensions","type":0,"sectionRef":"#","url":"/docs/SM-guide/python-in-td/extensions","content":"","keywords":"","version":"Next"},{"title":"Custom Class Objects‚Äã","type":1,"pageTitle":"Extensions","url":"/docs/SM-guide/python-in-td/extensions#custom-class-objects","content":" ","version":"Next","tagName":"h2"},{"title":"Type Hinting‚Äã","type":1,"pageTitle":"Extensions","url":"/docs/SM-guide/python-in-td/extensions#type-hinting","content":" As a quick reminder, Python is a dynamically typed language. Which is to say that unlike other languages where we must specify a variable type during it's creation, the type of a variable in Python is largely determined at run time. That makes for a very flexible language, but can create some challenges during development - it's easy to incorrectly pass an argument type and then spend valuable debugging only to discover that you pass a str instead of an int. Python now supports type hinting, which allows you to more easily track the argument type.  When possible, it is highly recommended that that you use type hints - not only for the benefits of autocompletion in VS Code, but also as a kindness to your fellow developers. Here are some quick resources about Type Hinting:  Real Python type hinting lessonmypy type hints cheat sheetPython docs typing  ","version":"Next","tagName":"h3"},{"title":"Doc Strings‚Äã","type":1,"pageTitle":"Extensions","url":"/docs/SM-guide/python-in-td/extensions#doc-strings","content":" def foo(arg1:int, arg2:str) -&gt; list: &quot;&quot;&quot;A silly example An example function that accepts two arguments, returns a list, and raises no errors. This is mostly to illustrate what doc strings might look like for a function. Args: arg1 `int`: Some integer arg2 `int`: Some integer Returns: my_list `list`: A list made up of arg1 and arg2 Raises: None &quot;&quot;&quot; my_list = [arg1, arg2] return my_list   ","version":"Next","tagName":"h3"},{"title":"Promoted Methods‚Äã","type":1,"pageTitle":"Extensions","url":"/docs/SM-guide/python-in-td/extensions#promoted-methods","content":" class Foo: def __init__(self, owner_op:OP) -&gt; None: self.My_op = owner_op def Promoted_method(self, some_int_arg:int) -&gt; None: pass   ","version":"Next","tagName":"h3"},{"title":"Internal Methods‚Äã","type":1,"pageTitle":"Extensions","url":"/docs/SM-guide/python-in-td/extensions#internal-methods","content":" class Foo: def __init__(self, owner_op:OP) -&gt; None: self.My_op = owner_op def internal_method(self, some_int_arg:int) -&gt; None: pass   ","version":"Next","tagName":"h3"},{"title":"Private Methods‚Äã","type":1,"pageTitle":"Extensions","url":"/docs/SM-guide/python-in-td/extensions#private-methods","content":" class Foo: def __init__(self, owner_op:OP) -&gt; None: self.My_op = owner_op def _private_method(self, some_int_arg:int) -&gt; None: pass   ","version":"Next","tagName":"h3"},{"title":"Singletons‚Äã","type":1,"pageTitle":"Extensions","url":"/docs/SM-guide/python-in-td/extensions#singletons","content":" Classes that belong to a single instance of an operator.  ","version":"Next","tagName":"h2"},{"title":"Common Characteristics‚Äã","type":1,"pageTitle":"Extensions","url":"/docs/SM-guide/python-in-td/extensions#common-characteristics","content":" class Output: def __init__(self, owner_op): self.Owner_op = owner_op def Touch_start(self): print('Running Touch Start | Output')   ","version":"Next","tagName":"h3"},{"title":"Other Class Objects‚Äã","type":1,"pageTitle":"Extensions","url":"/docs/SM-guide/python-in-td/extensions#other-class-objects","content":" ","version":"Next","tagName":"h2"},{"title":"Links to Derivative's official docs‚Äã","type":1,"pageTitle":"Extensions","url":"/docs/SM-guide/python-in-td/extensions#links-to-derivatives-official-docs","content":"","version":"Next","tagName":"h2"},{"title":"Modules","type":0,"sectionRef":"#","url":"/docs/SM-guide/python-in-td/modules","content":"","keywords":"","version":"Next"},{"title":"Namespace Collisions‚Äã","type":1,"pageTitle":"Modules","url":"/docs/SM-guide/python-in-td/modules#namespace-collisions","content":" Consider the following scenario - in your project you want write a wrapper for the python datetime library. It's not uncommon to want to modify standard libraries so they are a better fit for the TouchDesigner workflow, and writing a wrapper around a library like datetime is something you might do. Feeling clever, you decide to change the name of your Text DAT to datetime - since it is your new datetime library.    What's not to love about this? Next you want to call your new functions from another DAT. You add another DAT to your network and import datetime and call the functions you've just written.    At this point everything is coming up roses1. There is, however, a catch to this approach - what happens if we try to access the pure Python datetime library from our text1 DAT?    Errors abound. We've now created a complicated namespace - we are both importing the standard Python library called datetime and naming a Text DAT datetime which we are importing in the context of TouchDesigner as datetime. That means that only in our TextDAT version of datetime can we access any of the other functions in this library - which is deeply confusing. Said another way, we've overridden the standard library with our own module and created a namespace mess. For this reason, it's worth adopting a naming schema that helps ensure that these types of collisions are less likely to occur.  Generally speaking, we append MOD to the end of any Text DAT that's treated as a module on demand. In our case that would mean naming our datetime wrapper datetimeMOD.  ","version":"Next","tagName":"h2"},{"title":"When to use Modules‚Äã","type":1,"pageTitle":"Modules","url":"/docs/SM-guide/python-in-td/modules#when-to-use-modules","content":" The use of the mod class, and the ability to import Text DATs as modules on demand started with some of the earliest implementation of Python in TouchDesigner. This opened up a number of different avenues for working with Python, and also created spaces to define reusable code in Text DATs that could be used by many different execute Ops. This can be hugely beneficial with respect to maintaining a library of code that's used multiple places. That's a hugely powerful idea, especially in TouchDesigner, but it does have some limitations. One in particular being that it's difficult to maintain a persistent object or variable between executions.  Any given Text DAT has an independent scope - which means that the my_int of text1 isn't easily accessed by text2. It is possible to declare a variable globally from within a DAT, but that's often messier than it might seem - when using global variables in Python the opportunity for namespace collisions is very high, especially when working in an environment like TouchDesigner.  SudoMagic Practice Our general practice is to avoid using global Python variables in any project code.  ","version":"Next","tagName":"h2"},{"title":"Links to Derivative's official docs‚Äã","type":1,"pageTitle":"Modules","url":"/docs/SM-guide/python-in-td/modules#links-to-derivatives-official-docs","content":" MOD ClassPython Classes and Modules    Footnotes‚Äã For those unfamiliar, Ethel Merman's performance of Everything's Coming Up Roses once was the bee's knees. ‚Ü© ","version":"Next","tagName":"h2"},{"title":"System Configuration","type":0,"sectionRef":"#","url":"/docs/SM-guide/system-configuration","content":"","keywords":"","version":"Next"},{"title":"ipar Settings‚Äã","type":1,"pageTitle":"System Configuration","url":"/docs/SM-guide/system-configuration#ipar-settings","content":" Projects typically use a set of internal parameters located in the /base_scaffold/base_project. This set of internal parameters is called Settings, and allows pars to be accessed with the pattern ipar.Settings.Somepar. SudoMagic typically uses ipar.Settings as the primary interface for states that need to be set at start-up. All parameters on this base are saved out to file and loaded from file on start-up.  ","version":"Next","tagName":"h2"},{"title":"Read-Only pars‚Äã","type":1,"pageTitle":"System Configuration","url":"/docs/SM-guide/system-configuration#read-only-pars","content":" The notable exception for saved and loaded pars are those marked as read-only. Read-Only pars are not saved to file, and they are not set when a file is loaded from disk. This provides a stable interface for parameters that are referenced across the project, while also ensuring that some pars are private to the TOE file.  No Expressions Please Expressions, generally, should not be used for any parameters in ipar.Settings. This general practice is to ensure that pars with expression are not unexpectedly overwritten by the contents on disk. The exception to this rule is read-only pars - since read-only marked parameters are not loaded from disk, it is safe to use expressions in these parameters.  More here from the official Derivative documentation about Internal Parameters  ","version":"Next","tagName":"h3"},{"title":"Sane Defaults‚Äã","type":1,"pageTitle":"System Configuration","url":"/docs/SM-guide/system-configuration#sane-defaults","content":" There are some cases when the contents of ipar.Settings should be overridden with consistent and sane start-up defaults. For this reason, there is an additional json file in _public\\data labeled defaults.json - the contents of this file will override any parameter that might otherwise be loaded from disk.  ","version":"Next","tagName":"h3"},{"title":"Prefill‚Äã","type":1,"pageTitle":"System Configuration","url":"/docs/SM-guide/system-configuration#prefill","content":" The prefill parameter on the Texture 3D TOP and the Cache TOP have a reliable mechanic for loading frames into memory. The prefill operation happens during project start-up and reliably provides a cook and load pattern for frames that need to be cached. This is helpful for elements like images for slide-shows, but also useful for elements that may be used for UIs or other system-wide display. It's important to consider that this loading step blocks that launching or a project or loading of a TOX anytime a Texture3D or Cache loads many frames there is a high probability that it will delay the start-up of your project.  ","version":"Next","tagName":"h2"},{"title":"Touch_start‚Äã","type":1,"pageTitle":"System Configuration","url":"/docs/SM-guide/system-configuration#touch_start","content":" Touch_start() is a SudoMagic convention that arises out of the specific need for a reliable class object restart that does not require reinitializing the entire class object. Python object initialization is difficult to reliably predict, and our internal solution to address this need is to use an explicit class method that can be explicitly called. Because of the interplay of pull based mechanics and Python's integration, Touch_start() may not necessarily contain any methods. Calling a method in an Extension ensures that the class is initialized in the order desired.  ","version":"Next","tagName":"h2"},{"title":"Links to Derivative's official docs‚Äã","type":1,"pageTitle":"System Configuration","url":"/docs/SM-guide/system-configuration#links-to-derivatives-official-docs","content":" Internal ParametersCache TOPTexture 3D TOP    Footnotes‚Äã SudoMagic uses the term toy-network to mean a simplified example of an idea or concept that is not intended for production use. These small format networks often are used to tease out the subtly of an idea, or concept before working out the production implementation process. Toy-networks are typically located in the root of a repo in a directory called /prototypes or /sandbox. ‚Ü© ","version":"Next","tagName":"h2"},{"title":"Spectra Studio Style Guide","type":0,"sectionRef":"#","url":"/docs/spectra-studio","content":"Spectra Studio Style Guide Coming Soon üìÑÔ∏è Placeholder Placeholder","keywords":"","version":"Next"},{"title":"Placeholder","type":0,"sectionRef":"#","url":"/docs/spectra-studio/new-page","content":"Placeholder","keywords":"","version":"Next"},{"title":"Python Doc Strings","type":0,"sectionRef":"#","url":"/docs/SM-guide/python-in-td/py-td-doc-strings","content":"","keywords":"","version":"Next"},{"title":"Why Use Doc Strings?‚Äã","type":1,"pageTitle":"Python Doc Strings","url":"/docs/SM-guide/python-in-td/py-td-doc-strings#why-use-doc-strings","content":" Doc strings and comments are helpful in a number of different circumstances when reading and authoring code. Most importantly, these are the breadcrumbs and operating notes that you leave for your future self. In the heat of working on a project you rarely need a reminder about about how function or class works, but in 6 months... you might. Doc strings and comments are here to help ensure that the best ideas can keep getting used, and don't rewritten when it's more work to understand what the code does than to start over.  ","version":"Next","tagName":"h2"},{"title":"Examples‚Äã","type":1,"pageTitle":"Python Doc Strings","url":"/docs/SM-guide/python-in-td/py-td-doc-strings#examples","content":" ","version":"Next","tagName":"h2"},{"title":"Function‚Äã","type":1,"pageTitle":"Python Doc Strings","url":"/docs/SM-guide/python-in-td/py-td-doc-strings#function","content":" Practical Example‚Äã  def To_rgb_from_hex(value:str) -&gt; tuple: &quot;&quot;&quot;Returns a color as a float tuple (rgb) converted from HEX Args --------------- value (`str`) &gt; hex string to be converted into rgb Returns --------------- color (`tuple`) &gt; normalized color expressed as (r, g, b) tuple &quot;&quot;&quot;   Boiler Plate‚Äã  def Foo_bar(arg1:int) -&gt; None: &quot;&quot;&quot;Single line description of function. Any additional comments or operational considerations you'd like to add about the function in question. Args --------------- arg1 (`int`) &gt; description of arg's role Returns --------------- None &quot;&quot;&quot;   Short Form‚Äã  The short form usage is acceptable when there is a present type hint for any arguments and returns. Provided that hints are present, the doc string can be abridged to only include a brief description of the method / function.  def Foo_bar(arg1:str) -&gt; None: &quot;&quot;&quot;One line description Any additional comments or operational considerations you'd like to add about the method in question. &quot;&quot;     ","version":"Next","tagName":"h3"},{"title":"Header‚Äã","type":1,"pageTitle":"Python Doc Strings","url":"/docs/SM-guide/python-in-td/py-td-doc-strings#header","content":" Practical Example‚Äã  &quot;&quot;&quot; SudoMagic | sudomagic.com Authors | Matthew Ragan, Ian Shelanskey Contact | contact@sudomagic.com &quot;&quot;&quot; # td python mods import SudoMagic import Lookup # pure python import json import sys import socket import logging   Boiler Plate‚Äã  &quot;&quot;&quot; SudoMagic | sudomagic.com Authors | Matthew Ragan, Ian Shelanskey Contact | contact@sudomagic.com &quot;&quot;&quot; # td python mods import SudoMagic import Lookup # pure python     ","version":"Next","tagName":"h3"},{"title":"Class‚Äã","type":1,"pageTitle":"Python Doc Strings","url":"/docs/SM-guide/python-in-td/py-td-doc-strings#class","content":" Practical Example‚Äã  class Project(SudoMagic.Types.abstract_component_singleton): &quot;&quot;&quot;Project Class The project class is responsible for the construction and distribution of all extensions. _setup() constructs extensions in order, allowing for a reliable and consistent start-up sequence for all python extensions Additionally the Project class is responsible for start-up functions that include loading settings from file. &quot;&quot;&quot;   Boiler Plate‚Äã  class Foo: &quot;&quot;&quot;Foo Class one line description Any additional comments or operational considerations you'd like to add about the class in question. &quot;&quot;&quot;     ","version":"Next","tagName":"h3"},{"title":"Method‚Äã","type":1,"pageTitle":"Python Doc Strings","url":"/docs/SM-guide/python-in-td/py-td-doc-strings#method","content":" Practical Example‚Äã  def Set_process(self, override_role:str) -&gt; None: &quot;&quot;&quot;sets process from available processes in config overrides provided env var and runs Touch_start() Args --------------- override_role (`str`) &gt; new string to set for role Returns --------------- None &quot;&quot;&quot;   Boiler Plate‚Äã  def Bar(self, arg1:str) -&gt; None: &quot;&quot;&quot;One line description Any additional comments or operational considerations you'd like to add about the method in question. Args --------------- self (`callable`) &gt; new string to set for role arg1 (`str`) &gt; some argument description Returns --------------- None &quot;&quot;&quot;   Short Form‚Äã  The short form usage is acceptable when there is a present type hint for any arguments and returns. Provided that hints are present, the doc string can be abridged to only include a brief description of the method / function.  def Bar(self, arg1:str) -&gt; None: &quot;&quot;&quot;One line description Any additional comments or operational considerations you'd like to add about the method in question. &quot;&quot;&quot;   ","version":"Next","tagName":"h3"},{"title":"Links to Derivative's official docs‚Äã","type":1,"pageTitle":"Python Doc Strings","url":"/docs/SM-guide/python-in-td/py-td-doc-strings#links-to-derivatives-official-docs","content":" MOD Class ","version":"Next","tagName":"h2"},{"title":"Placeholder","type":0,"sectionRef":"#","url":"/docs/worksofar-guide/new-page","content":"Placeholder","keywords":"","version":"Next"},{"title":"Worksofar Style Guide","type":0,"sectionRef":"#","url":"/docs/worksofar-guide","content":"Worksofar Style Guide Whatever preamble you'd like to add here üìÑÔ∏è Placeholder Placeholder","keywords":"","version":"Next"},{"title":"Auto-Complete","type":0,"sectionRef":"#","url":"/docs/SM-guide/python-in-td/py-td-auto-complete","content":"","keywords":"","version":"Next"},{"title":"Your Code Editor and Python‚Äã","type":1,"pageTitle":"Auto-Complete","url":"/docs/SM-guide/python-in-td/py-td-auto-complete#your-code-editor-and-python","content":" This short diversion is for TouchDesigner devs who don't have a strong Python background. The way we use Python in TouchDesigner is a little different than the development of a pure Python App. The description that is going to follow is a bit of a simplification of what's actually happening in exchange for brevity. If you're interested, it's worth diving into the complete description of the Python import system.  It's worth taking a moment to revisit these ideas, as having a deeper understanding of how your code editor understands and works with Python is going to impact our ability to have an autocomplete system in place. Our goal, in this exercise, is for our code editor to autocomplete the methods we author in our extensions and modules. This significantly increases our development speed, and reduces the opportunity for errors - but it does stand on understanding some of the deeper technical elements that Python stands on top of.  For all of these examples and discussion we're working with Visual Studio Code as a code editor.  ","version":"Next","tagName":"h2"},{"title":"Importing - back to the basics‚Äã","type":1,"pageTitle":"Auto-Complete","url":"/docs/SM-guide/python-in-td/py-td-auto-complete#importing---back-to-the-basics","content":" To start, we need to first visit some basics of the Python paradigm.  ","version":"Next","tagName":"h2"},{"title":"what is import‚Äã","type":1,"pageTitle":"Auto-Complete","url":"/docs/SM-guide/python-in-td/py-td-auto-complete#what-is-import","content":" The import keyword is used to invoke the python import system. Broadly speaking, in many languages code is written in smaller modules or libraries that are then included in larger projects. This organizes code into smaller chunks that are both reusable and more easily maintained (developing smaller libraries that allow parallel development or management is sometimes referred to as &quot;orthogonal&quot; ).  The import keyword tells Python that there‚Äôs a set of functions outside of the default python tool set that are going to be accessed in any given module or library. As a best practice, import statements typically happen at the top of a module, and are outside of any functions so that their scope (your ability to use them) allows them to be used by any function in that module.  For example - this syntax is also completely functional:  def UpdateDateTimeBuffer( datetime_buffer ): import datetime datetime_buffer.clear() datetime_object = datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) datetime_buffer.write(datetime_object) return def FetchDateAndTime(): import datetime return datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)   The above is just redundant - if we only import dateteime in the local scope of function, no other function can use it, and we subsequently need to re-import in every function. This is why you typically see this instead:  import datetime def UpdateDateTimeBuffer( datetime_buffer ): datetime_buffer.clear() datetime_object = datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) datetime_buffer.write(datetime_object) return def FetchDateAndTime(): return datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)   The datetime library is available to all functions, which is typically what we want. As a final note, you can technically do this, but you shouldn't:  def UpdateDateTimeBuffer( datetime_buffer ): datetime_buffer.clear() datetime_object = datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) datetime_buffer.write(datetime_object) return import datetime def FetchDateAndTime(): return datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)   warning This is considered bad form since it would be difficult for another developer to find that hidden import statement.  ","version":"Next","tagName":"h3"},{"title":"Where does it come from?‚Äã","type":1,"pageTitle":"Auto-Complete","url":"/docs/SM-guide/python-in-td/py-td-auto-complete#where-does-it-come-from","content":" To python, the import statement typically refers to a .py file or folder on your computer. datetime, for example can be found in your TouchDesigner installer folder, a typical installation location is:  C:\\Program Files\\Derivative\\TouchDesigner.2021.15240\\bin\\Lib    ","version":"Next","tagName":"h3"},{"title":"Writing our own Module‚Äã","type":1,"pageTitle":"Auto-Complete","url":"/docs/SM-guide/python-in-td/py-td-auto-complete#writing-our-own-module","content":" We're going to do a pure Python review of importing. This assumes that you already have Python installed on your machine, and that you're comfortable with a code editor. It's okay if you're not there yet, just know this section may feel like it's leaving out smaller steps.  ","version":"Next","tagName":"h2"},{"title":"Using a module example‚Äã","type":1,"pageTitle":"Auto-Complete","url":"/docs/SM-guide/python-in-td/py-td-auto-complete#using-a-module-example","content":" Let's start by creating a directory called python-import-example. In here we're going to create two files:  example-python-script.pysomeMod.py  Let's open this directory with our code editor, and also open up the console. You should have something like this:    Next let's add a simple function to our someMod.py file.  def My_great_function(some_number:int) -&gt; None: print(some_number)   Let's save that while we're at it, and we should now have something that looks like this in our code editor:    Next let's head back to our example-python-script.py file. At the top of this file we'll use the import keyword to the other code we just wrote as a module:  import someMod     VS Code knows we're using Python - and as such, it will now offer to autocomplete code for us. We can see this in action if we start by typing someMod. - at this point we'll see a list of all the available functions that are in the module we've created:    This is great, in part because it keeps us in this module, and not going back to try and remember what we wrote. If we have doc strings in our other module those will also appear for us in the autocomplete (a quick note, I went back and added a doc string so we could see this in action).    ","version":"Next","tagName":"h3"},{"title":"Using a class example‚Äã","type":1,"pageTitle":"Auto-Complete","url":"/docs/SM-guide/python-in-td/py-td-auto-complete#using-a-class-example","content":" Let's keep moving forward from this idea, and instead of working with just a module, let's work with a class. In Object Oriented Programming, we think of class objects as templates for a specific instance of that item. When we think of a single instance of a class object, that design pattern is referred to a Singleton. Most of the extensions we write in TouchDesigner are Singletons, and when we're organizing our TouchDesigner networks into bigger components, like a Communication or Data base that severs our whole project, this is Singleton.  With that in mind let's look at how we we might write an import pattern for a Singleton. Let's start by adding a directory called Foo to our folder. Next we're going to add the following files in that directory:  __init__.pyFooEXT.py  Next let's add a little bit of code to the FooEXT.py file:  class FooSingleton: def __init__(self): print('Ground control to Major Foo') def Bar(self): print('Sometimes you eat the bar, and sometimes the bar eats you')   In the __init__.py file we can now add the following:  import FooEXT MyFoo = FooEXT.FooSingleton   Here we import FooEXT and then create a new variable MyFoo that points to the FooSingleton class object in FooEXT.  That means back in our example-python-script.py file we can do the following:  import someMod import Foo someMod.My_great_function(10) Foo.MyFoo.Bar()   In VS Code, we now also get the autocomplete options from our Singleton:    ","version":"Next","tagName":"h3"},{"title":"Back to TouchDesigner‚Äã","type":1,"pageTitle":"Auto-Complete","url":"/docs/SM-guide/python-in-td/py-td-auto-complete#back-to-touchdesigner","content":" In TouchDesigner this gets both complicated, and interesting. Where this becomes complicated is in relationship to the MOD Class. The contents of any DAT can be treated as though they were a module. In TouchDesigner the import keyword operates on DATs, the way import works on files in pure Python. We can take advantage of both this so that we can both use extensions as you might in TouchDesigner, and get the advantages of autocomplete in VS Code.  To get started, we have to make a few compromises. For this to work best, we need to first centralize where our extensions are going to live both in TouchDesigner and in our project's directory structure. We also have to commit to using external files for our extensions.  ","version":"Next","tagName":"h2"},{"title":"An Extension Manager‚Äã","type":1,"pageTitle":"Auto-Complete","url":"/docs/SM-guide/python-in-td/py-td-auto-complete#an-extension-manager","content":" In TouchDesigner we're going to keep all of our extensions in an operator called base_ext_manager:    In our extension manager we'll have all of our extensions in DATs whose names match their file names in python:    In VS Code we'll see that we've created a new directory for each extension, and in that directory is an __init__.py file and the extension file. The name space is important here, so take a moment to see the pattern we've created.  Finally, we create one extra module called lookup which is going to act as the bridge for both TouchDesigner and VS Code. Here we're going to perform a little magic trick that using type hinting (our ability to tell Python that an object is supposed to match an known object).  Let's look at what's in lookup:  from __future__ import annotations try: import Project import Data import Output except: pass PROJECT:Project.Project = op.PROJECT DATA:Data.Data = op.DATA OUTPUT:Output.Output = op.OUTPUT   annotations let's us take advantage of a try and accept block that's only for VS Code. This let's VS Code interpret our import statement in order to offer us code completion. This let's us tell VS Code that our variable PROJECT in code is actually a Project.Project object (which is our extension Singleton), while TouchDesigner will see this variable as pointing to the global op shortcut op.PROJECT. In this way, the variable PROJECT to TouchDesigner is the operator (which has a promoted extension), and to VS Code PROJECT is a proper Python Object.  ","version":"Next","tagName":"h3"},{"title":"The Magic of Local Modules‚Äã","type":1,"pageTitle":"Auto-Complete","url":"/docs/SM-guide/python-in-td/py-td-auto-complete#the-magic-of-local-modules","content":" This is all great for Extensions, but there is one other feature of the MOD Class that we can take advantage of in TouchDesigner. The MOD Class allows the use of two nested base COMPs local/modules to hold the a collection of Python modules that are the first location TouchDesigner will search during import. We can use this to our advantage when building reusable libraries that we want to keep out of extensions.  Let's say, for example, that we want to have access to the datetime module in our extensions. It would be redundant to import this into each extension. Instead we might create a collection of tools that follow a functional paradigm that we can then use from a single location. This reduces the likelihood that we'll repeat ourselves, and will help us keep a cleaner code base.  To do this let's first create a new directory in our td-python directory called projectTools. In this directory we'll create two files:  __init__.pyMyTime.py  In the __init__.py file let's import our MyTime.py file:  import MyTime   In MyTime we can add a simple function for now:  import datetime def TD_now(): return datetime.datetime.now()   You should have something that looks like this:    in TouchDesigner let's start by creating our base ops, let's next navigate into local/modules and add two text DATs.    We can now go back to our Project extension and import projectTools:  import lookup import projectTools class Project: def __init__(self, owner_op): self.Owner_op = owner_op print(f'Project Init at | {projectTools.MyTime.TD_now()}') def Touch_start(self): print('Running Touch Start | Project') lookup.DATA.Touch_start() lookup.OUTPUT.Touch_start() def Promoted_project_method(self): ...   ","version":"Next","tagName":"h2"},{"title":"It's okay to be confused‚Äã","type":1,"pageTitle":"Auto-Complete","url":"/docs/SM-guide/python-in-td/py-td-auto-complete#its-okay-to-be-confused","content":" This is a confusing concept - in part because of how extensions and modules work in TouchDesigner. The benefits here, however, are that we can now have a more seamless development workflow in VS Code. It also means that when collaborating with others, you can treat extensions and modules much more like proper Python.  ","version":"Next","tagName":"h2"},{"title":"Sample Repo‚Äã","type":1,"pageTitle":"Auto-Complete","url":"/docs/SM-guide/python-in-td/py-td-auto-complete#sample-repo","content":" If you're still scratching your head, that's okay. Download this repo to see how these concepts work in action.  MIR Sample Autocomplete  ","version":"Next","tagName":"h3"},{"title":"Links to Derivative's official docs‚Äã","type":1,"pageTitle":"Auto-Complete","url":"/docs/SM-guide/python-in-td/py-td-auto-complete#links-to-derivatives-official-docs","content":"","version":"Next","tagName":"h2"}],"options":{"id":"default"}}